#!/usr/bin/env python

from dynamic_reconfigure.parameter_generator_catkin import *
#from local_planner_limits import add_generic_localplanner_params

gen = ParameterGenerator()

# This unusual line allows to reuse existing parameter definitions
# that concern all localplanners
#add_generic_localplanner_params(gen)

# For integers and doubles:
#       Name                    Type      Reconfiguration level
#       Description
#       Default  Min  Max


# Trajectory
gen.add("teb_autosize",   bool_t,   0, 
	"Enable the automatic resizing of the trajectory during optimization (based on the temporal resolution of the trajectory, recommended)",
	True)

gen.add("dt_ref", double_t, 0, 
	"Temporal resolution of the planned trajectory (usually it is set to the magnitude of the 1/control_rate)",
	0.3, 0.01,  1)

gen.add("dt_hysteresis", double_t, 0, 
	"Hysteresis that is utilized for automatic resizing depending on the current temporal resolution (dt): usually 10% of dt_ref",
	0.1, 0.002,  0.5)

gen.add("global_plan_overwrite_orientation",   bool_t,   0,
	"Some global planners are not considering the orientation at local subgoals between start and global goal, therefore determine it automatically",
	True)
	
gen.add("force_reinit_new_goal_dist",   double_t,   0,
	"Force the planner to reinitialize the trajectory if a previous goal is updated with a seperation of more than the specified value in meters (skip hot-starting)",
	1.0, 0.0, 10.0)	
    
# Robot
gen.add("max_vel_x", double_t, 0, 
	"Maximum translational velocity of the robot",
	0.4, 0.01, 2)   

gen.add("max_vel_x_backwards", double_t, 0, 
	"Maximum translational velocity of the robot for driving backwards",
	0.2, 0.01, 2)   
    
gen.add("max_vel_theta", double_t, 0,
	"Maximum angular velocity of the robot", 
	0.3, 0.01, 2) 

gen.add("acc_lim_x", double_t, 0, 
	"Maximum translational acceleration of the robot",
	0.5, 0.01, 2)   
    
gen.add("acc_lim_theta", double_t, 0,
	"Maximum angular acceleration of the robot", 
	0.5, 0.01, 2)  
  
# GoalTolerance
gen.add("xy_goal_tolerance", double_t, 0,
	"Allowed final euclidean distance to the goal position",
	0.2, 0.001, 2) 
    
gen.add("yaw_goal_tolerance", double_t, 0, 
	"Allowed final orientation error to the goal orientation", 
	0.1, 0.001, 2)

gen.add("free_goal_vel",   bool_t,   0, 
	"Allow the robot's velocity to be nonzero for planning purposes (the robot can arrive at the goal with max speed)", 
	False)
    
# Obstacles
gen.add("min_obstacle_dist", double_t, 0, 
	"Minimum desired separation from obstacles", 
	0.5, 0, 3)     

gen.add("costmap_emergency_stop_dist", double_t, 0, 
	"Force stop moving if the distance to costmap obstacles is below the given threshold",
	0.3, 0, 3) 

gen.add("include_costmap_obstacles",   bool_t,   0, 
	"Specify whether the obstacles in the costmap should be taken into account directly (this is necessary if no seperate clustering and detection is implemented)", 
	True)

gen.add("costmap_obstacles_front_only",   bool_t,   0, 
	"Limit the considered costmap obstacles to the front of the robot (much more efficient)", 
	True)

gen.add("obstacle_poses_affected",    int_t,    0, 
	"The obstacle position is attached to the closest pose on the trajectory to reduce computational effort, but take a number of neighbors into account as well", 
	10, 0, 100)
	
gen.add("line_obstacle_poses_affected",    int_t,    0, 
	"See obstacle_poses_affected, but here for obstacles of line shape", 
	25, 0, 100)

gen.add("polygon_obstacle_poses_affected",    int_t,    0, 
	"See obstacle_poses_affected, but here for obstacles of polygonial shape", 
	25, 0, 100)

# Optimization
    
gen.add("no_inner_iterations",    int_t,    0,
	"Number of solver iterations called in each outerloop iteration", 
	5, 1, 100)

gen.add("no_outer_iterations",    int_t,    0, 
	"Each outerloop iteration automatically resizes the trajectory and invokes the internal optimizer with no_inner_iterations", 
	4, 1, 100)

gen.add("optimization_activate",   bool_t,   0,
	"Activate the optimization",
	True)

gen.add("optimization_verbose",   bool_t,   0, 
	"Print verbose information", 
	False)

gen.add("penalty_scale", double_t, 0,
	"Lower values increase the penalty cost for hard-constraint approximations (do not choose too low: no satisfaction of constraints, or too high: bad matrix conditions)", 
	0.1, 0.001, 1) 
    
gen.add("penalty_epsilon", double_t, 0, 
	"Add a small safty margin to penalty functions for hard-constraint approximations",
	0.1, 0, 0.3) 

gen.add("weight_max_vel_x", double_t, 0, 
	"Optimization weight for satisfying the maximum allowed translational velocity", 
	0, 2, 1000) 

gen.add("weight_max_vel_theta", double_t, 0, 
	"Optimization weight for satisfying the maximum allowed angular velocity", 
	0, 1, 1000) 

gen.add("weight_acc_lim_x", double_t, 0, 
	"Optimization weight for satisfying the maximum allowed translational acceleration", 
	0, 1, 1000)
 
gen.add("weight_acc_lim_theta", double_t, 0, 
	"Optimization weight for satisfying the maximum allowed angular acceleration",
	0, 1, 1000) 

gen.add("weight_kinematics_nh", double_t, 0,
	"Optimization weight for satisfying the non-holonomic kinematics", 
	1000 , 0, 10000) 

gen.add("weight_kinematics_forward_drive", double_t, 0, 
	"Optimization weight for forcing the robot to choose only forward directions (positive transl. velocities)", 
	1, 0, 1000) 

gen.add("weight_optimaltime", double_t, 0, 
	"Optimization weight for contracting the trajectory w.r.t transition time", 
	1, 0, 1000) 

gen.add("weight_point_obstacle", double_t, 0, 
	"Optimization weight for satisfying a minimum seperation from point obstacles",
	50, 0, 1000) 

gen.add("weight_line_obstacle", double_t, 0, 
	"Optimization weight for satisfying a minimum seperation from line obstacles", 
	50, 0, 1000) 	
	
gen.add("weight_poly_obstacle", double_t, 0, 
	"Optimization weight for satisfying a minimum seperation from polygon obstacles", 
	10, 0, 1000) 

gen.add("weight_dynamic_obstacle", double_t, 0, 
	"Optimization weight for satisfying a minimum seperation from dynamic obstacles", 
	10, 0, 1000) 

gen.add("alternative_time_cost",   bool_t,   0, 
	"Not in use yet...", 
	False)

# Homotopy Class Planner
    
gen.add("enable_multithreading",    bool_t,    0,
	"Activate multiple threading for planning multiple trajectories in parallel", 
	True)

gen.add("simple_exploration",    bool_t,    0,
	"If true, the homotopies are explored usign a simple left-right approach (pass each obstacle on the left or right side) for path generation, otherwise sample possible roadmaps randomly in a specified region between start and goal", 
	False)

gen.add("max_number_classes",    int_t,    0,
	"Specify the maximum number of allowed alternative homotopy classes (limits computational effort)", 
	5, 1, 100)

gen.add("roadmap_graph_no_samples",    int_t,    0,
	"Specify the number of samples generated for creating the roadmap graph, if simple_exploration is turend off", 
	15, 1, 100)

gen.add("roadmap_graph_area_width", double_t, 0, 
	"Specify the width of the area in which sampled will be generated between start and goal [m] (the height equals the start-goal distance)", 
	6, 0.1, 20) 

gen.add("h_signature_prescaler", double_t, 0, 
	"Scale number of obstacle value in order to allow huge number of obstacles. Do not choose it extremly low, otherwise obstacles cannot be distinguished from each other (0.2<H<=1)", 
	1, 0.2, 1) 

gen.add("h_signature_threshold", double_t, 0, 
	"Two h-signuteres are assumed to be equal, if both the difference of real parts and complex parts are below the specified threshold", 
	0.01, 0, 1) 

gen.add("obstacle_keypoint_offset", double_t, 0, 
	"If simple_exploration is turned on, this parameter determines the distance on the left and right side of the obstacle at which a new keypoint will be cretead (in addition to min_obstacle_dist)", 
	0.1, 0, 5) 

gen.add("obstacle_heading_threshold", double_t, 0, 
	"Specify the value of the normalized scalar product between obstacle heading and goal heading in order to take them (obstacles) into account for exploration)", 
	0.45, 0, 1) 

gen.add("visualize_hc_graph",    bool_t,    0,
	"Visualize the graph that is created for exploring new homotopy classes", 
	False)

exit(gen.generate("teb_local_planner", "teb_local_planner", "TebLocalPlannerReconfigure"))
